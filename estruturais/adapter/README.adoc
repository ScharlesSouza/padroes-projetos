:imagesdir: ../../images/patterns/estruturais
:source-highlighter: highlightjs
:numbered:
:unsafe:
:icons: font

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padr√µes de Projetos Estruturais

== Adapter (Adaptador)

.https://youtu.be/45I9jX5uO9A
https://youtu.be/45I9jX5uO9A[image:adapter-tomada.jpg[]]

=== Defini√ß√£o

üìò"O padr√£o adapter converte a interface de uma classe em outra interface que os clientes esperam. O adaptador permite que classes anteriormente incompat√≠veis possam trabalhar em conjunto". <<UCPP>>

=== Aplicabilidade

Um dos casos onde o adapter √© amplamente aplicado √© quando utiliza-se um determinado servi√ßo web ou biblioteca onde existem diferentes implementa√ß√µes destes, cada uma funcionando de uma forma diferente. Logo, o c√≥digo necess√°rio para usar um(a) determinado(a) servi√ßo/biblioteca/framework seria diferente de outro. Normalmente v√£o existir v√°rios m√©todos com nomes e par√¢metros diferentes (assinaturas). Assim, trocar tal servi√ßo/biblioteca/framework por outro(a) pode ser um trabalho complexo. 

Um adapter neste caso pode fornecer uma interface padr√£o a ser utilizada publicamente, encapsulando as diferen√ßas entre um(a) servi√ßo/biblioteca/framework e outro(a).

=== Modelagem do Padr√£o

.Modelagem do padr√£o adapter
image::adapter.png[]

Podemos ter 1 ou mais classes que precisam ser adaptadas, como as classes `AdaptadaAbc` e `AdaptadaXyz`.
Cada uma dessas classes fornecem implementa√ß√µes diferentes de uma determinada funcionalidade.
Por exemplo, cada classe pode representar o acesso a um determinado servi√ßo na web,
como obten√ß√£o da previs√£o do tempo. Cada uma obt√©m a previs√£o de um servi√ßo (site) diferente.
Podemos ter v√°rios m√©todos diferentes que fornecem as mesmas funcionalidades, como obten√ß√£o da previs√£o para uma determinada data, m√©dia de temperatura para um determinado m√™s do ano, umidade relativa do ar, etc. No entanto, os m√©todos, par√¢metros e tipos de cada uma dessas classes (como possivelmente foram implementadas por pessoas/equipes distintas), ser√£o diferentes. 

Para padronizarmos tais m√©todos e assim tornar id√™ntica a forma de usar qualquer uma dessas classes, devemos implementar um adaptador para cada classe a ser adaptada. No diagrama de exemplo, a classe `AdaptadaAbc` possui os m√©todos `metodoA()` e `metodoB()`. J√° a  classe `AdaptadaXyz` possui os m√©todos `metodoY()` e `metodoX()`. A padroniza√ß√£o pode ser feita pela cria√ß√£o de uma interface comum (`Alvo`) que ser√° implementada por cada adaptador. O nome de cada classe Adapter normalmente √© formado pelo nome da classe a ser adaptada, seguido da palavra `Adapter`. Assim, temos as classes `AbcAdapter` e `XyzAdapter` para o modelo apresentado. Uma classe `AbcAdapter` que implementa a interface `Alvo` √© um adaptador para a classe `AdaptadaAbc`. Em outras palavras, ela adapta objetos `AdaptadaAbc` para funcionarem como se fossem do tipo `Alvo`.

`Cliente` √© uma classe qualquer que vai usar esta interface para se comunicar com os objetos adaptados por meio de seus adaptadores.
Assim, se a classe `Cliente` precisar trocar um objeto por outro, como o objeto ser√° acessador por meio da interface `Alvo`, n√£o precisaremos alterar a forma de utilizar um novo objeto.

Observe que, por exemplo, um m√©todo como `metodo1()` na classe `AbcAdapter` vai apenas delegar a chamada para o `metodoA()` de um objeto `AbcAdapter`.

Um projeto de exemplo para o diagrama apresentado est√° dispon√≠vel link:modelagem[aqui]. Ele deve ser alterado para incluir as mudan√ßas necess√°rias para o problema espec√≠fico que voc√™ estiver resolvendo com o padr√£o.

Voc√™ pode entender melhor o diagrama da Figura 1 fazendo uma analogia com o adaptador de tomada como a Figura 2 abaixo.

.Analogia da Modelagem do Padr√£o Adapter com um Adaptador de Tomada
image::adapter-analogia-tomada.png[]

=== Princ√≠pios utilizados

-

=== Exemplos

- Gera√ß√£o de n√∫meros verdadeiramente aleat√≥rios utilizando servi√ßos web como o http://random.org e http://random.irb.hr

== Padr√µes Relacionados

- Decorator

== Onde o padr√£o √© usado no JDK e outras bibliotecas

O adaptador https://logging.apache.org/log4j/log4j-2.7/log4j-jul/index.html[Apache Log4J JUL Adapter] permite utilizar a biblioteca https://logging.apache.org/log4j/[Apache Log4J] com o mesmo c√≥digo exigido pela biblioteca JUL (java.util.logging) do JDK. Assim, se seu projeto estava usando a biblioteca JUL e deseja trocar pela Log4J, basta utilizar tal Adapter e assim n√£o precisar√° alterar o c√≥digo existente.

== Exerc√≠cios

=== Cota√ß√µes de Empresas da Bolsa de Valores

A partir do projeto base link:cotacao-bolsa-valores[cotacao-bolsa-valores], 
que realiza a cota√ß√£o de a√ß√µes de empresas da bolsa de valores, implemente as classes
Adapter para padronizar a interface de acesso a tais servi√ßos.

No projeto disponibilizado, a classe `Principal` √© na nossa classe `Cliente` (como apresentado na Figura 1): √© ela quem usa os adaptadores. Analisando o novo c√≥digo da classe principal, que outro padr√£o poder√≠amos aplicar em seguida?

=== Adaptando a aplica√ß√£o de consulta de CEP (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/estruturais/adapter/cep-service-adapter[zip])

Voltando ao link:../../criacionais/cep-service/cep-service-producer[projeto que utiliza servi√ßos de consulta de CEP] dispon√≠veis na web, cada servi√ßo retorna um objeto endere√ßo em um formato diferente do outro, como pode verificar nestes links para o https://viacep.com.br/ws/01001000/json/[ViaCep] e o https://api.postmon.com.br/v1/cep/77021090[Postmon].

Como o problema aqui √© referente ao formato dos dados, precisamos apena adapter os dados para um formato comum.
Assim, a implementa√ß√£o n√£o precisa seguir a modelagem apresentada na Figura 1 acima.
Uma solu√ß√£o simples, que n√£o requer a cria√ß√£o de classes adapters, √© apresentada abaixo.
Voc√™ precisar√° fazer o processamento manual do c√≥digo JSON recebido
pelo servi√ßo, que representa o endere√ßo de um determinado CEP.
Para isso, podemos usar a biblioteca https://javaee.github.io/jsonp/getting-started.html[JSON-P (JSON Processing)] da plataforma Java para o Quarkus, adicionando a depend√™ncia a seguir no pom.xml:

[source,xml]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jsonp</artifactId>
      <version>${quarkus.version}</version>
    </dependency>
----

//No JavaEE tradicional as depend√™ncias s√£o javax.json/javax.json-api e org.glassfish/javax.json

Voc√™ pode usar um c√≥digo como abaixo para fazer o tal processamento:

[source,java]
----
JsonReader reader = Json.createReader(new StringReader(json));
JsonObject object = reader.readObject();
Endereco endereco = new Endereco();
endereco.setLogradouro(object.getString("logradouro"));
----

Alternativamente, veja o projeto link:cep-service-adapter-automatico[cep-service-adapter-automatico], 
que apenas usa recursos da biblioteca https://github.com/FasterXML/jackson[Jackson] e assim n√£o requer a implementa√ß√£o do padr√£o Adapter.

=== Pensando em interfaces como adaptadores

Em um classe que implementa m√∫ltiplas interfaces, podemos pensar na classe como sendo um adaptador para todas estas interfaces. Apesar de nem sempre o padr√£o Adapter est√° sendo de fato implementado nestes casos, ao pensar assim, podemos ter alguns benef√≠cios.

Na Java Collections Framework (JCF), classes como ArrayList e LinkedList funcionam como adaptadores para a interface List, pois alguns m√©todos t√™m assinaturas diferente uns dos outros. 
Na classe ArrayList, utiliza-se `elementData(index)` para acessar um elemento 
em uma determinada posi√ß√£o. Na classe LinkedList utiliza-se `node(index).item`.
Mesmo as duas classes tendo sido implementadas em conjunto, elas representam estruturas
de dados muito diferentes. Para tornar seu uso uniforme para n√≥s desenvolvedores, 
os m√©todos citados n√£o s√£o p√∫blicos. Temos o `public E get(int index)` em tais classes,
que √© herdado da interface `List`. Tal m√©todo padroniza o acesso aos elementos.

Classes como ArrayList e LinkedList implementam m√∫ltiplas interfaces em uma hierarquia como List -> Collection -> Iterable. Tal hierarquia nos permite usar um ArrayList como se fosse um objeto List, Collection ou Iterable, de acordo com suas necessidades.

Como exemplo, veja o seguinte m√©todo com uma implementa√ß√£o n√£o ideal:

[source,java]
----
private void imprimir(ArrayList<Double> elementos){
    for (Double e : elementos) {
        System.out.println(e);
    }

    elementos.clear();
}
----

Como pode ver, o m√©todo recebe um ArrayList, imprime todos os valores e apaga seus elementos.
Pense em como podemos criar as seguintes vers√µes deste m√©todo para:

1. imprimir qualquer tipo de lista (ArrayList, LinkedList, etc)
2. impedir que a lista seja modificada (por exemplo, pela remo√ß√£o de elementos)
3. imprimir qualquer tipo de cole√ß√£o (ArrayList, LinkedList, HashSet, TreeSet, etc)