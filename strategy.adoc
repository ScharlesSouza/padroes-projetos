:imagesdir: images/patterns/
:source-highlighter: highlightjs
:numbered:
:unsafe:

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padrões de Projetos Comportamentais (Behavioural Design Patterns)

== Strategy (Estratégia)

=== Definição

"O padrão Strategy define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis. A estratégia deixa o algoritmo variar independentemente dos clientes que o utilizam" <<UCPP>>.

Em outras palavras, a partir de um conjunto de algoritmos, permite que classes possam trocar tais algoritmos por uma outra implementação, até mesmo em tempo de execução.

=== Aplicabilidade

Pode ser aplicado quando:

- o comportamento de um método (implementação de um algoritmo) precisa ser diferente em classes distintas e/ou mudar em tempo de execução;
- determinadas classes devem ter um comportamento específico (método) e outras não;
- não deseja-se que uma alteração em uma super classe afete sub classes.

=== Modelagem do Padrão

image::strategy-base-class-diagram.png[]

A `SuperClasse` é que que irá usar as estratégias, que são representadas pelas classes que implementam os comportamentos.
Cada comportamento (estratégia) é normalmente definido como uma interface. Assim, podem existir N implementações de cada comportamento (diferentes estratégias).

Perceba que a relação entre a `SuperClasse` e os comportamentos não é herança, mas pode ser uma associação normal, composição ou agregação. Cada comportamento não é implementado como uma subclasse da `SuperClasse`, cada tipo de comportamento estará contido como um atributo dentro da `SuperClasse`. Por isso é comum representar como agregação/composição. Definindo o comportamento como atributo é que nos permite alterar em tempo de execução sua implementação.

O comportamento em si é definido por um método na interface. No exemplo, o método é `executarComportamentoA()` para o `ComportamentoA`. O nome do método é o desenvolvedor quem define, normalmente sendo um nome que faça sentido para o sistema.
A assinatura do método também é livre. Neste exemplo o método não recebe parâmetros e retorna um tipo genérico `T`. O tipo do retorno vai depender das suas necessidades. Veja os exemplos concretos na seção a seguir.

Podem existir diferentes classes filhas desta `SuperClasse`. Cada classe filha podem ter comportamentos diferentes umas das outras.
Com o padrão Strategy, o comportamento de qualquer classe (mãe ou filha) pode mudar em tempo de execução, de acordo com os requisitos do sistema.


=== Princípios utilizados

- https://en.wikipedia.org/wiki/Composition_over_inheritance[Favorecer composição no lugar de herança].
- https://tuhrig.de/programming-to-an-interface/[Programar para uma "interface" não uma implementação] (GoF).
- https://en.wikipedia.org/wiki/Open–closed_principle[Open/Closed Principle (OCP)], pois separa as partes que mudam (os comportamentos) de dentro da classe que utiliza eles. Isto torna a classe "aberta para extensão e fechada para modificação" (em relação aos comportamentos).
- https://en.wikipedia.org/wiki/Single_responsibility_principle[Single Responsibility Principle (SRP)] pois a classe que usa os comportamentos não tem a responsabilidade de implementar estes comportamentos. 
- https://en.wikipedia.org/wiki/Liskov_substitution_principle[Liskov Substitution Principle (LSP)] pois podemos substituir um comportamento por qualquer implementação dele, de forma transparente, até mesmo em tempo de execução, sem que sejam necessárias alterações no código interno da classe que utiliza tais comportamentos.
- https://en.wikipedia.org/wiki/Interface_segregation_principle[Interface Segregation Principle (ISP)], pois estamos definindo diferentes interfaces com multiplas implementações específicas, no lugar juntar estas diferentes implementações apenas nas classes que utilizam tais comportamentos.

=== Exemplos

==== Leitura de arquivos de retorno de boletos bancários.

Arquivos de retorno são enviados pelos bancos às empresas, fornecendo uma lista de boletos
pagos por clientes, para que tais empresas possam registrar o pagamento desses boletos
em seus sistemas. Os bancos utilizam um arquivo de texto com campos de comprimento fixo, onde não existe um caractere delimitador. Cada campo tem uma quantidade fixa de caracteres. Se o valor possui menos caracteres do que deveria, o tamanho é completado com espaços em branco.

Um aplicação na empresa recebedora dos boletos deve ler tais arquivos para extrair os dados
e normalmente gravar em um banco de dados. Existem diferentes formatos para tais arquivos
e cada banco pode utilizar um formato diferente. Atualmente existem inúmeros projetos em diferentes linguagens para fazer a leitura de tais arquivos, https://github.com/manoelcampos/retorno-boletophp[como este]. Vamos implementar um solução simplificada aqui apenas para efeitos didáticos.

NOTE: Apesar de atualmente termos formatos de arquivos mais utilizados como JSON e XML, formatos como o mencionado ainda são bastante utilizados, principalmente no meio acadêmico, por serem simplista. Um outro exemplo de tais formatos são os arquivos https://pt.wikipedia.org/wiki/Comma-separated_values[CSV]. Mas em aplicações Web e mobile, o mais comum é o uso de JSON e XML.

Para este exemplo, vamos considerar que o Banco do Brasil usa um tipo de arquivo onde cada linha com as informações sobre o pagamento de um boleto contém os seguintes campos de tamanho fixo (sem separador entre eles):

- id do boleto com 10 dígitos
- código do banco onde o boleto foi pago, com 3 dígitos
- data vencimento no formato dd/mm/yyyy
- data pagamento no formato dd/mm/yyyy
- CPF do cliente com 10 dígitos
- valor do boleto no formato decimal 10,2
- multa por atraso no formato decimal 10,2
- juros no formato no formato decimal 10,2

Mas digamos que você também precisa receber arquivos do Bradesco que possui o seguinte formato:

- id do boleto com 10 dígitos
- código do banco onde o boleto foi pago, com 3 dígitos
- *agência onde o boleto foi pago, com 6 dígitos
- *conta do cliente para possível extorno de pagamento, com 9 dígitos
- data vencimento no formato dd/mm/yyyy
- *data/hora pagamento no formato dd/mm/yyyy hh:nn:ss
- CPF do cliente com 10 dígitos
- *valor do boleto no formato decimal 12,2
- *multa por atraso no formato decimal 12,2
- *juros no formato no formato decimal 12,2

*__Campos adicionais ou diferentes do formato anterior.__

Um diagrama de classes para tal implementação pode ser como abaixo.

image:retorno-boleto-class-diagram.png[]

=== Possíveis Problemas

Mesmo que uma classe não tenha um determinado comportamento, como o definido pela interface `ComportamentoA`, haverá uma associação entre a classe e o comportamento.
Se a classe não precisar de uma implementação de tal comportamento, o atributo que representa a associação pode estar nulo. Ao tentar usar o comportamento é gerada a exceção `NullPointerException`.

Para resolver isso, podemos criar uma classe que implemente o comportamento, mas que tenha uma implementação vazia, não fazendo nada.
Isto normalmente pode ser implementado pelo padrão Null Object que veremos posteriormente.

=== Modelagem utilizando Programação Funcional

Observando o diagrama base para a implementação do padrão Strategy, pode-se perceber que são criadas muitas classes e interfaces. Cada classes implementando essas interfaces não possuem atributos e têm apenas um único método que representa a implementaçãoo em si da estratégia.

Graças à Programação Funcional em diversas linguagens como Java 8+, JavaScript, PHP, Phython e outras, podemos simplificar este diagrama, e consequentemente a implementação, drasticamente como mostra a figura a seguir.

image:strategy-base-funcional-class-diagram.png[]

Observe que não temos mais as interfaces e classes específicas dos comportamentos.
Como cada comportamento nada mais é do que a implementação de um método (como o `executarComportamentoA()` do primeiro diagrama), podemos ter um atributo, na classe que usará tais comportamentos, que é simplesmente uma referência (um ponteiro, link) para o método a ser utilizado. 

Assim, o atributo como `comportamentoA` é do tipo `Function`, um tipo básico do Java 8+ que indica que o atributo não armazena dados, mas sim uma referência para um método que a classe pode chamar. Sendo que a referência para o método está armazenada em um atributo, se tivermos um método como o `comportamentoA1` mostrado no primeiro diagrama, podemos armazenar uma referência para tal método no atributo `comportamentoA`.
Se precisarmos fazer a super classe ou qualquer subclasse usar um comportamento diferente, podemos atribuir, por exemplo, o método `comportamentoA2` ao atributo `comportamentoA` em tempo de execução.

`Function` é uma das interfaces em Java 8+ que permite representar métodos isolados e armazenar referências deles em variáveis. 
Estas são chamadas de interfaces funcionais.

Em linguagens distintas, a forma de implementar o padrão strategy usando programação funcional é diferente.

== Modelagem convencional sem o padrão Strategy

A modelagem convencional de diferentes comportamentos sem o uso do padrão Strategy requer o uso de herança para os diferentes comportamentos e é visualmente mais simples.
No entanto, tal implementação tem algumas características que podem ser um problema, dependendo dos requisitos do seu sistema, por não permitir:

- alterar um comportamento em tempo de execução;
- comportilhar implementações de um mesmo comportamento entre diferentes classes filhas, levando à duplicação de código (que deve ser evitado ao máximo);
- combinar comportamentos distintos em um só, reaproveitando código.

image:no-strategy-class-diagram.png[]